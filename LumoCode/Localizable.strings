//
//  Localizable.strings
//  LumoCode
//
//  Created by Iosif Gogolos on 31.08.25.
//
// Localizable.strings (German - de)

// Welcome Screen
"welcome_to" = "Willkommen bei";
"app_name" = "LumoCode";
"app_description" = "Lerne Swift spielerisch mit Lumo dem schlauen Fuchs!";
"your_name" = "Dein Name";
"lets_go" = "Los geht's!";

// Category Selection
"hello_user" = "Hallo %@! üëã";
"choose_category" = "W√§hle eine Kategorie";
"questions_count" = "%d Fragen";

// Categories
"swift_basics" = "Swift Grundlagen";
"functions" = "Funktionen";
"loops" = "Schleifen";

// Quiz
"correct" = "‚úÖ Richtig!";
"wrong" = "‚ùå Leider falsch!";
"explanation" = "Erkl√§rung:";
"continue" = "Weiter";
"points" = "Punkte: %d";
"streak" = "Streak: %d";

// Summary
"quiz_completed" = "üéâ Quiz beendet!";
"total_points" = "Gesamtpunkte";
"accuracy" = "Genauigkeit";
"best_streak" = "Beste Streak";
"excellent" = "Ausgezeichnet! üåü";
"excellent_message" = "Du beherrschst Swift wirklich gut!";
"good_job" = "Gut gemacht! üëç";
"good_job_message" = "Du bist auf dem richtigen Weg!";
"practice_makes_perfect" = "√úbung macht den Meister! üí™";
"practice_message" = "Probiere es nochmal - du schaffst das!";
"try_again" = "Nochmal versuchen";
"other_category" = "Andere Kategorie";

// Questions - Swift Basics
"q_variable_declaration" = "Welches Schl√ºsselwort wird verwendet, um eine Variable zu deklarieren?";
"e_variable_declaration" = "Mit 'var' deklariert man ver√§nderbare Variablen in Swift.";
"q_constant_creation" = "Wie erstellt man eine Konstante in Swift?";
"e_constant_creation" = "Das Schl√ºsselwort 'let' erstellt unver√§nderbare Konstanten.";
"q_integer_type" = "Welcher Datentyp wird f√ºr ganze Zahlen verwendet?";
"e_integer_type" = "Int ist der Standard-Datentyp f√ºr ganze Zahlen in Swift.";

// Questions - Functions
"q_function_definition" = "Wie definiert man eine Funktion in Swift?";
"e_function_definition" = "Funktionen werden mit dem Schl√ºsselwort 'func' definiert.";
"q_function_return" = "Wie gibt eine Funktion einen Wert zur√ºck?";
"e_function_return" = "Das Schl√ºsselwort 'return' gibt einen Wert aus der Funktion zur√ºck.";

// Questions - Loops
"q_for_in_loop" = "Welche Schleife wiederholt Code f√ºr jedes Element?";
"e_for_in_loop" = "For-in Schleifen iterieren √ºber Sammlungen von Elementen.";
"q_repeat_while" = "Welche Schleife f√ºhrt Code mindestens einmal aus?";
"e_repeat_while" = "Repeat-while Schleifen f√ºhren den Code mindestens einmal aus.";

// Neue Kategorien
"oop_basics" = "Objektorientierung";
"error_handling" = "Fehlerbehandlung";
"swiftui_basics" = "SwiftUI Grundlagen";

// Swift Grundlagen - Erweiterte Fragen
"q_string_interpolation" = "Wie f√ºgt man Variablen in Strings ein?";
"e_string_interpolation" = "String-Interpolation verwendet \\() um Variablen in Strings einzuf√ºgen.";

"q_optional_syntax" = "Wie deklariert man einen Optional in Swift?";
"e_optional_syntax" = "Ein Fragezeichen (?) nach dem Typ macht eine Variable optional.";

"q_nil_check" = "Wie pr√ºft man auf einen leeren Optional-Wert?";
"e_nil_check" = "nil ist der leere Wert f√ºr Optionals in Swift.";

"q_force_unwrap" = "Wie erzwingt man das Entpacken eines Optionals?";
"e_force_unwrap" = "Das Ausrufezeichen (!) erzwingt das Entpacken, kann aber crashen wenn nil.";

"q_type_inference" = "Was ist Type Inference in Swift?";
"e_type_inference" = "Swift kann Datentypen automatisch aus dem Kontext ableiten.";

"q_array_declaration" = "Wie deklariert man ein Array in Swift?";
"e_array_declaration" = "Sowohl [Int]() als auch Array<Int> sind g√ºltige Array-Deklarationen.";

"q_dictionary_syntax" = "Wie ist die Syntax f√ºr Dictionaries?";
"e_dictionary_syntax" = "Dictionaries verwenden [Key: Value] Syntax.";

"q_tuple_syntax" = "Wie erstellt man ein Tuple?";
"e_tuple_syntax" = "Tuples verwenden Klammern: (Type1, Type2).";

"q_enum_definition" = "Wie definiert man ein Enum?";
"e_enum_definition" = "Enums werden mit 'enum Name { case value }' definiert.";

"q_struct_vs_class" = "Was ist der Hauptunterschied zwischen Struct und Class?";
"e_struct_vs_class" = "Structs sind Werttypen (kopiert), Classes sind Referenztypen (referenziert).";

"q_computed_property" = "Wie definiert man eine Computed Property?";
"e_computed_property" = "Computed Properties haben einen get-Block und optional einen set-Block.";

"q_guard_statement" = "Wof√ºr verwendet man guard statements?";
"e_guard_statement" = "Guard statements erm√∂glichen fr√ºhe R√ºckkehr und verbessern die Lesbarkeit.";

// Funktionen - Erweiterte Fragen
"q_function_parameters" = "Wie definiert man Parameter in Funktionen?";
"e_function_parameters" = "Parameter haben ein Label und einen Typ: (name: String).";

"q_function_return_type" = "Wie gibt man den R√ºckgabetyp an?";
"e_function_return_type" = "Der Pfeil (->) zeigt den R√ºckgabetyp an.";

"q_external_parameter" = "Wie erstellt man externe Parameter-Labels?";
"e_external_parameter" = "Externes Label vor internem: func greet(to name: String).";

"q_default_parameter" = "Wie setzt man Default-Werte f√ºr Parameter?";
"e_default_parameter" = "Default-Werte werden mit = gesetzt.";

"q_variadic_parameter" = "Wie akzeptiert eine Funktion mehrere Werte?";
"e_variadic_parameter" = "Drei Punkte (...) nach dem Typ erlauben mehrere Werte.";

"q_inout_parameter" = "Wie √ºbergibt man Parameter by reference?";
"e_inout_parameter" = "inout Parameter erm√∂glichen √Ñnderungen der urspr√ºnglichen Variable.";

"q_closure_syntax" = "Wie ist die Syntax f√ºr Closures?";
"e_closure_syntax" = "Closures verwenden geschweifte Klammern mit 'in' Keyword.";

"q_trailing_closure" = "Was sind Trailing Closures?";
"e_trailing_closure" = "Wenn der letzte Parameter ein Closure ist, kann es nach den Klammern stehen.";

"q_higher_order_function" = "Welche Higher-Order Functions gibt es in Swift?";
"e_higher_order_function" = "map, filter, reduce sind die wichtigsten Higher-Order Functions.";

"q_escaping_closure" = "Wann braucht man @escaping bei Closures?";
"e_escaping_closure" = "@escaping wird ben√∂tigt wenn das Closure nach der Funktion ausgef√ºhrt wird.";

// Schleifen - Erweiterte Fragen
"q_range_operator" = "Welcher Operator erstellt einen geschlossenen Bereich?";
"e_range_operator" = "Drei Punkte (...) erstellen einen geschlossenen Bereich.";

"q_half_open_range" = "Welcher Operator erstellt einen halboffenen Bereich?";
"e_half_open_range" = "..<  erstellt einen Bereich der das Ende ausschlie√üt.";

"q_break_statement" = "Was macht das break Statement?";
"e_break_statement" = "break beendet die aktuelle Schleife oder switch-Anweisung sofort.";

"q_continue_statement" = "Was macht das continue Statement?";
"e_continue_statement" = "continue √ºberspringt den Rest der aktuellen Iteration.";

"q_labeled_statement" = "Wie erstellt man benannte Schleifen?";
"e_labeled_statement" = "Labels vor Schleifen erm√∂glichen gezieltes break/continue.";

"q_where_clause" = "Wie f√ºgt man Bedingungen zu Schleifen hinzu?";
"e_where_clause" = "where-Klauseln filtern Iterationen basierend auf Bedingungen.";

"q_switch_statement" = "Wie ist die Syntax f√ºr switch statements?";
"e_switch_statement" = "switch nimmt einen Wert und pr√ºft verschiedene cases.";

"q_fallthrough_keyword" = "Wie f√ºhrt man mehrere cases aus?";
"e_fallthrough_keyword" = "fallthrough f√ºhrt den n√§chsten case ebenfalls aus.";

// Objektorientierung
"q_class_definition" = "Wie definiert man eine Klasse?";
"e_class_definition" = "Klassen werden mit dem 'class' Keyword definiert.";

"q_inheritance_syntax" = "Wie erbt eine Klasse von einer anderen?";
"e_inheritance_syntax" = "Doppelpunkt (:) zeigt Vererbung an.";

"q_override_keyword" = "Wie √ºberschreibt man Methoden?";
"e_override_keyword" = "override Keyword ist erforderlich um Methoden zu √ºberschreiben.";

"q_initializer_syntax" = "Wie definiert man Initializer?";
"e_initializer_syntax" = "init Keyword definiert Konstruktoren.";

"q_designated_initializer" = "Was ist ein Designated Initializer?";
"e_designated_initializer" = "Der Haupt-Initializer der alle Properties initialisiert.";

"q_convenience_initializer" = "Was ist ein Convenience Initializer?";
"e_convenience_initializer" = "convenience Initializer rufen andere Initializer auf.";

"q_deinitializer" = "Wie definiert man Destruktoren?";
"e_deinitializer" = "deinit wird aufgerufen wenn ein Objekt zerst√∂rt wird.";

"q_access_control_private" = "Welches Keyword macht Properties privat?";
"e_access_control_private" = "private beschr√§nkt Zugriff auf die aktuelle Datei.";

"q_access_control_public" = "Was ist der Unterschied zwischen public und open?";
"e_access_control_public" = "public erlaubt Zugriff, open zus√§tzlich Vererbung au√üerhalb des Moduls.";

"q_static_property" = "Wie erstellt man Class Properties?";
"e_static_property" = "static und class erstellen Properties die zur Klasse geh√∂ren.";

"q_weak_reference" = "Wie vermeidet man Retain Cycles?";
"e_weak_reference" = "weak Referenzen verhindern starke Referenzzyklen.";

"q_protocol_definition" = "Wie definiert man Protocols?";
"e_protocol_definition" = "protocol Keyword definiert Schnittstellen.";

// Fehlerbehandlung
"q_error_protocol" = "Welches Protocol m√ºssen Fehler implementieren?";
"e_error_protocol" = "Error Protocol ist die Basis f√ºr alle Fehlertypen.";

"q_throwing_function" = "Wie markiert man Funktionen die Fehler werfen?";
"e_throwing_function" = "throws Keyword nach den Parametern.";

"q_try_keyword" = "Wie ruft man Funktionen auf die Fehler werfen k√∂nnen?";
"e_try_keyword" = "try Keyword vor dem Funktionsaufruf.";

"q_do_catch_syntax" = "Wie f√§ngt man Fehler ab?";
"e_do_catch_syntax" = "do-catch Bl√∂cke fangen und behandeln Fehler.";

"q_try_optional" = "Wie macht man try optional?";
"e_try_optional" = "try? gibt nil zur√ºck wenn ein Fehler auftritt.";

"q_try_force" = "Wie erzwingt man try ohne Fehlerbehandlung?";
"e_try_force" = "try! crasht das Programm wenn ein Fehler auftritt.";

"q_defer_statement" = "Wie f√ºhrt man Cleanup-Code aus?";
"e_defer_statement" = "defer f√ºhrt Code aus bevor der Scope verlassen wird.";

"q_result_type" = "Welcher Typ repr√§sentiert Erfolg oder Fehler?";
"e_result_type" = "Result<Success, Failure> kapselt Erfolg oder Fehler.";

// SwiftUI
"q_view_protocol" = "Welches Protocol m√ºssen SwiftUI Views implementieren?";
"e_view_protocol" = "View Protocol definiert die body Property.";

"q_body_property" = "Wie ist die Signatur der body Property?";
"e_body_property" = "some View erlaubt opaque return types.";

"q_state_property" = "Welches Property Wrapper verwaltet lokalen State?";
"e_state_property" = "@State f√ºr lokale, ver√§nderbare Daten.";

"q_binding_property" = "Welches Property Wrapper verbindet Parent und Child Views?";
"e_binding_property" = "@Binding erm√∂glicht bidirektionale Daten√ºbertragung.";

"q_observableobject" = "Wie observiert man externe Objekte?";
"e_observableobject" = "@StateObject f√ºr Eigentum, @ObservedObject f√ºr Referenzen.";

"q_vstack_hstack" = "Was ist der Unterschied zwischen VStack und HStack?";
"e_vstack_hstack" = "VStack arrangiert vertikal, HStack horizontal.";

"q_navigationview" = "Wie erstellt man Navigation in SwiftUI?";
"e_navigationview" = "NavigationView (iOS 13+) oder NavigationStack (iOS 16+) erm√∂glicht hierarchische Navigation.";

